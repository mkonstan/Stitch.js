<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stitch.js - Edge Cases Test Suite</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background: #f5f5f5; }
        .test-header { background: #2c3e50; color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        .version-selector { margin: 20px 0; padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .version-selector button { padding: 10px 20px; margin: 0 10px; border: 2px solid #3498db; background: white; color: #3498db; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold; }
        .version-selector button.active { background: #3498db; color: white; }
        .test-section { background: white; padding: 20px; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .test-section h2 { margin-top: 0; color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
        .test-case { margin: 15px 0; padding: 15px; background: #f8f9fa; border-left: 4px solid #95a5a6; border-radius: 4px; }
        .test-case.pass { border-left-color: #27ae60; background: #d5f4e6; }
        .test-case.fail { border-left-color: #e74c3c; background: #fadbd8; }
        .test-title { font-weight: bold; color: #2c3e50; margin-bottom: 10px; }
        .assertion { margin: 5px 0; padding: 8px; border-radius: 3px; }
        .assertion.pass { background: #d5f4e6; color: #27ae60; }
        .assertion.pass::before { content: "‚úì "; font-weight: bold; }
        .assertion.fail { background: #fadbd8; color: #e74c3c; }
        .assertion.fail::before { content: "‚úó "; font-weight: bold; }
        .summary { position: sticky; top: 20px; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); margin-bottom: 20px; }
        .summary-stats { display: flex; justify-content: space-around; margin-top: 15px; }
        .stat { text-align: center; }
        .stat-value { font-size: 32px; font-weight: bold; margin: 5px 0; }
        .stat-label { font-size: 12px; color: #7f8c8d; text-transform: uppercase; }
        .stat.pass .stat-value { color: #27ae60; }
        .stat.fail .stat-value { color: #e74c3c; }
        .stat.total .stat-value { color: #3498db; }
    </style>
</head>
<body>
    <div class="test-header">
        <h1>üî¨ Stitch.js Edge Cases Test Suite</h1>
        <p>Testing deep nesting, null/undefined, type conversions, and edge cases</p>
    </div>

    <div class="test-controls" style="margin: 20px 0; padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); text-align: center;">
        <button onclick="runAllTests()" style="padding: 10px 20px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold;">‚ñ∂Ô∏è Run All Tests</button>
    </div>

    <div class="summary" id="summary">
        <h3 style="margin-top: 0;">Test Summary</h3>
        <div class="summary-stats">
            <div class="stat total"><div class="stat-value" id="totalTests">0</div><div class="stat-label">Total Tests</div></div>
            <div class="stat pass"><div class="stat-value" id="passedTests">0</div><div class="stat-label">Passed</div></div>
            <div class="stat fail"><div class="stat-value" id="failedTests">0</div><div class="stat-label">Failed</div></div>
        </div>
    </div>

    <div id="testContainer"></div>
    <script id="stitchScript" src="stitch.js"></script>

    <script>
        Stitch.debug.enable(); // Enable debug mode for detailed logging
        let testResults = [];

        function assert(condition, message) {
            return { pass: condition, message: message };
        }

        function assertEqual(actual, expected, description) {
            const pass = actual === expected;
            return { pass: pass, message: `${description}: Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}` };
        }

        function createTestSection(title) {
            const section = document.createElement('div');
            section.className = 'test-section';
            section.innerHTML = `<h2>${title}</h2>`;
            return section;
        }

        function renderTestCase(section, testName, assertions) {
            const allPass = assertions.every(a => a.pass);
            const testCase = document.createElement('div');
            testCase.className = `test-case ${allPass ? 'pass' : 'fail'}`;
            let html = `<div class="test-title">${testName}</div>`;
            assertions.forEach(assertion => {
                html += `<div class="assertion ${assertion.pass ? 'pass' : 'fail'}">${assertion.message}</div>`;
            });
            testCase.innerHTML = html;
            section.appendChild(testCase);
            return allPass;
        }

        function updateSummary() {
            const total = testResults.length;
            const passed = testResults.filter(r => r.passed).length;
            document.getElementById('totalTests').textContent = total;
            document.getElementById('passedTests').textContent = passed;
            document.getElementById('failedTests').textContent = total - passed;
        }

        // TEST 1: Deep Nesting (10 levels)
        function testDeepNesting() {
            const section = createTestSection('Test 1: Deep Nesting (10 Levels)');

            const model = Stitch.Observable.create({
                l1: { l2: { l3: { l4: { l5: { l6: { l7: { l8: { l9: { l10: { value: 'deep' } } } } } } } } } }
            });

            const assertions = [
                assertEqual(model.l1.l2.l3.l4.l5.l6.l7.l8.l9.l10.value, 'deep', '10-level deep access works'),
            ];

            model.l1.l2.l3.l4.l5.l6.l7.l8.l9.l10.value = 'updated';
            assertions.push(
                assertEqual(model.l1.l2.l3.l4.l5.l6.l7.l8.l9.l10.value, 'updated', '10-level deep update works')
            );

            testResults.push({ name: '1.1', passed: renderTestCase(section, '1.1: 10-Level Deep Nesting', assertions) });
            document.getElementById('testContainer').appendChild(section);
        }

        // TEST 2: Null and Undefined Handling
        function testNullUndefined() {
            const section = createTestSection('Test 2: Null and Undefined Handling');

            const model = Stitch.Observable.create({
                nullValue: null,
                undefinedValue: undefined,
                normalValue: 'test'
            });

            const assertions = [
                assertEqual(model.nullValue, null, 'Null value preserved'),
                assertEqual(model.undefinedValue, undefined, 'Undefined value preserved'),
                assertEqual(model.normalValue, 'test', 'Normal value works')
            ];

            model.nullValue = 'no longer null';
            assertions.push(assertEqual(model.nullValue, 'no longer null', 'Null changed to value'));

            model.normalValue = null;
            assertions.push(assertEqual(model.normalValue, null, 'Value changed to null'));

            testResults.push({ name: '2.1', passed: renderTestCase(section, '2.1: Null/Undefined Values', assertions) });
            document.getElementById('testContainer').appendChild(section);
        }

        // TEST 3: Type Conversions
        function testTypeConversions() {
            const section = createTestSection('Test 3: Type Conversions');

            const container = document.createElement('div');
            container.innerHTML = `
                <input type="number" data-value="numValue" data-type="int">
                <input type="checkbox" data-value="boolValue">
            `;
            document.body.appendChild(container);

            const model = Stitch.Observable.create({
                numValue: 42,
                boolValue: false
            });

            const binder = new Stitch.DataBinder();
            binder.bind(container, model);

            setTimeout(() => {
                const numInput = container.querySelector('[type="number"]');
                const checkInput = container.querySelector('[type="checkbox"]');

                const assertions = [
                    assertEqual(numInput.value, '42', 'Number converted to string for input'),
                    assert(!checkInput.checked, 'Boolean false = unchecked')
                ];

                numInput.value = '100';
                numInput.dispatchEvent(new Event('input', { bubbles: true }));
                setTimeout(() => {
                    assertions.push(
                        assertEqual(model.numValue, 100, 'String converted back to number'),
                        assert(typeof model.numValue === 'number', 'Value is actually a number type')
                    );

                    checkInput.checked = true;
                    checkInput.dispatchEvent(new Event('change', { bubbles: true }));
                    setTimeout(() => {
                        assertions.push(
                            assertEqual(model.boolValue, true, 'Checkbox state converted to boolean')
                        );

                        document.body.removeChild(container);
                        testResults.push({ name: '3.1', passed: renderTestCase(section, '3.1: Type Conversions', assertions) });
                        document.getElementById('testContainer').appendChild(section);
                        testEmptyObjects();
                    }, 50);
                }, 50);
            }, 50);
        }

        // TEST 4: Empty Objects and Arrays
        function testEmptyObjects() {
            const section = createTestSection('Test 4: Empty Objects and Arrays');

            const model = Stitch.Observable.create({
                emptyObj: {},
                emptyArray: [],
                normalObj: { key: 'value' }
            });

            const assertions = [
                assert(Object.keys(model.emptyObj).length === 0, 'Empty object has no keys'),
                assertEqual(model.emptyArray.length, 0, 'Empty array has length 0'),
                assertEqual(model.normalObj.key, 'value', 'Normal object works')
            ];

            model.emptyObj.newKey = 'added';
            assertions.push(
                assertEqual(model.emptyObj.newKey, 'added', 'Added property to empty object')
            );

            model.emptyArray.push('item');
            assertions.push(
                assertEqual(model.emptyArray.length, 1, 'Added item to empty array'),
                assertEqual(model.emptyArray[0], 'item', 'Item value correct')
            );

            testResults.push({ name: '4.1', passed: renderTestCase(section, '4.1: Empty Objects and Arrays', assertions) });
            document.getElementById('testContainer').appendChild(section);
            testSpecialChars();
        }

        // TEST 5: Special Characters in Property Names
        function testSpecialChars() {
            const section = createTestSection('Test 5: Special Characters in Property Names');

            const model = Stitch.Observable.create({
                'property-with-dash': 'value1',
                'property_with_underscore': 'value2',
                'property.with.dots': 'value3',
                'property with spaces': 'value4'
            });

            const assertions = [
                assertEqual(model['property-with-dash'], 'value1', 'Dash in property name'),
                assertEqual(model['property_with_underscore'], 'value2', 'Underscore in property name'),
                assertEqual(model['property.with.dots'], 'value3', 'Dots in property name'),
                assertEqual(model['property with spaces'], 'value4', 'Spaces in property name')
            ];

            model['property-with-dash'] = 'updated1';
            assertions.push(
                assertEqual(model['property-with-dash'], 'updated1', 'Updated property with dash')
            );

            testResults.push({ name: '5.1', passed: renderTestCase(section, '5.1: Special Characters in Keys', assertions) });
            document.getElementById('testContainer').appendChild(section);
            testMixedArrays();
        }

        // TEST 6: Mixed Data Types in Arrays
        function testMixedArrays() {
            const section = createTestSection('Test 6: Mixed Data Types in Arrays');

            const model = Stitch.Observable.create({
                mixed: [
                    'string',
                    42,
                    true,
                    null,
                    { obj: 'value' },
                    [1, 2, 3]
                ]
            });

            const assertions = [
                assertEqual(model.mixed.length, 6, 'Array has 6 elements'),
                assertEqual(model.mixed[0], 'string', 'String element'),
                assertEqual(model.mixed[1], 42, 'Number element'),
                assertEqual(model.mixed[2], true, 'Boolean element'),
                assertEqual(model.mixed[3], null, 'Null element'),
                assertEqual(model.mixed[4].obj, 'value', 'Object element'),
                assertEqual(model.mixed[5][1], 2, 'Nested array element')
            ];

            model.mixed.push(undefined);
            assertions.push(
                assertEqual(model.mixed.length, 7, 'Added undefined to array'),
                assertEqual(model.mixed[6], undefined, 'Undefined element accessible')
            );

            testResults.push({ name: '6.1', passed: renderTestCase(section, '6.1: Mixed Type Arrays', assertions) });
            document.getElementById('testContainer').appendChild(section);
            testToJSON();
        }

        // TEST 7: toJSON Method
        function testToJSON() {
            const section = createTestSection('Test 7: toJSON Serialization');

            const model = Stitch.Observable.create({
                name: 'Test',
                count: 42,
                nested: { value: 'deep' },
                computed: Stitch.computed(function() {
                    return this.count * 2;
                })
            });

            const json = model.toJSON();
            const assertions = [
                assertEqual(json.name, 'Test', 'toJSON includes name'),
                assertEqual(json.count, 42, 'toJSON includes count'),
                assertEqual(json.nested.value, 'deep', 'toJSON includes nested'),
                assertEqual(json.computed, 84, 'toJSON includes computed value')
            ];

            const jsonString = JSON.stringify(model);
            const parsed = JSON.parse(jsonString);
            assertions.push(
                assertEqual(parsed.name, 'Test', 'JSON.stringify works'),
                assertEqual(parsed.computed, 84, 'Computed in JSON.stringify')
            );

            testResults.push({ name: '7.1', passed: renderTestCase(section, '7.1: toJSON Method', assertions) });
            document.getElementById('testContainer').appendChild(section);
            updateSummary();
        }

        function runAllTests() {
            testResults = [];
            document.getElementById('testContainer').innerHTML = '';
            testDeepNesting();
            testNullUndefined();
            testTypeConversions();
        }

        window.addEventListener('load', () => { setTimeout(runAllTests, 100); });
    </script>
</body>
</html>
